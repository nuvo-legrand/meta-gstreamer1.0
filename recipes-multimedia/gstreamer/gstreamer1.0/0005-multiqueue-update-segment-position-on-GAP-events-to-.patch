From 9438cc4c69f92b422f99c4d64c44f7c5edb56e4c Mon Sep 17 00:00:00 2001
From: Matej Knopp <matej.knopp@gmail.com>
Date: Sat, 27 Sep 2014 20:10:34 +0200
Subject: [PATCH 5/7] multiqueue: update segment position on GAP events to
 calculate levels properly

https://bugzilla.gnome.org/show_bug.cgi?id=737498
---
 plugins/elements/gstmultiqueue.c | 42 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/plugins/elements/gstmultiqueue.c b/plugins/elements/gstmultiqueue.c
index a61c04c..e7f9887 100644
--- a/plugins/elements/gstmultiqueue.c
+++ b/plugins/elements/gstmultiqueue.c
@@ -1113,6 +1113,38 @@ apply_buffer (GstMultiQueue * mq, GstSingleQueue * sq, GstClockTime timestamp,
   gst_multi_queue_post_buffering (mq);
 }
 
+static void
+apply_gap (GstMultiQueue * mq, GstSingleQueue * sq, GstEvent * event,
+    GstSegment * segment)
+{
+  GstClockTime timestamp;
+  GstClockTime duration;
+
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
+
+  gst_event_parse_gap (event, &timestamp, &duration);
+
+  if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
+
+    if (GST_CLOCK_TIME_IS_VALID (duration)) {
+      timestamp += duration;
+    }
+
+    segment->position = timestamp;
+
+    if (segment == &sq->sink_segment)
+      sq->sink_tainted = TRUE;
+    else
+      sq->src_tainted = TRUE;
+
+    /* calc diff with other end */
+    update_time_level (mq, sq);
+  }
+
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
+  gst_multi_queue_post_buffering (mq);
+}
+
 static GstClockTime
 get_running_time (GstSegment * segment, GstMiniObject * object, gboolean end)
 {
@@ -1208,6 +1240,11 @@ gst_single_queue_push_one (GstMultiQueue * mq, GstSingleQueue * sq,
         /* Applying the segment may have made the queue non-full again, unblock it if needed */
         gst_data_queue_limits_changed (sq->queue);
         break;
+      case GST_EVENT_GAP:
+        apply_gap (mq, sq, event, &sq->src_segment);
+        /* Applying the gap may have made the queue non-full again, unblock it if needed */
+        gst_data_queue_limits_changed (sq->queue);
+        break;
       default:
         break;
     }
@@ -1693,7 +1730,9 @@ gst_multi_queue_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 
       gst_single_queue_flush (mq, sq, FALSE, FALSE);
       goto done;
+
     case GST_EVENT_SEGMENT:
+    case GST_EVENT_GAP:
       /* take ref because the queue will take ownership and we need the event
        * afterwards to update the segment */
       sref = gst_event_ref (event);
@@ -1755,6 +1794,9 @@ gst_multi_queue_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
       apply_segment (mq, sq, sref, &sq->sink_segment);
       gst_event_unref (sref);
       break;
+    case GST_EVENT_GAP:
+      apply_gap (mq, sq, sref, &sq->sink_segment);
+      gst_event_unref (sref);
     default:
       break;
   }
-- 
1.8.1.2

